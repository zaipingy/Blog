---
layout: post
title:  "angr 断点"
categories: angr
tags:  angr
author: zaipingy
---

* content
{:toc}

angr支持下断点：

```
>>> import angr
>>> b = angr.Project('examples/fauxware/fauxware')

# get our state
>>> s = b.factory.entry_state()

# add a breakpoint. This breakpoint will drop into ipdb right before a memory write happens.
>>> s.inspect.b('mem_write')

# on the other hand, we can have a breakpoint trigger right *after* a memory write happens. 
# we can also have a callback function run instead of opening ipdb.
>>> def debug_func(state):
...     print "State %s is about to do a memory write!"

>>> s.inspect.b('mem_write', when=angr.BP_AFTER, action=debug_func)

# or, you can have it drop you in an embedded IPython!
>>> s.inspect.b('mem_write', when=angr.BP_AFTER, action=angr.BP_IPYTHON)
```





通过inspect来增加断点，后面的string参数是断点函数名，还可以自定义一个函数来选择到达断点时执行的操作（action参数）。

以下是可以下断点的函数名：
![alt](http://zaipingy.top/static/upload/20171209/eapETgHm8fypvLDxUrGvWbVs.PNG)

还有很多其他的可选参数在angr的文档中，有点多，直接给出链接：[链接文本](www.yourlink.com)


可以自定义一个函数去限制程序下断点的位置：

```
# this is a complex condition that could do anything! In this case, it makes sure that RAX is 0x41414141 and
# that the basic block starting at 0x8004 was executed sometime in this path's history
>>> def cond(state):
...     return state.eval(state.regs.rax, cast_to=str) == 'AAAA' and 0x8004 in state.inspect.backtrace

>>> s.inspect.b('mem_write', condition=cond)
```