---
layout: post
title:  "牛客刷题"
categories: 牛客
tags:  牛客 算法 C
author: zaipingy
---

* content
{:toc}

# 合唱团
## 题目描述

```
有 n 个学生站成一排，每个学生有一个能力值，牛牛想从这 n 个学生中按照顺序选取 k 名学生，要求相邻两个学生的位置编号的差不超过 d，使得这 k 个学生的能力值的乘积最大，你能返回最大的乘积吗？
```





## 输入描述:

```
每个输入包含 1 个测试用例。每个测试数据的第一行包含一个整数 n (1 <= n <= 50)，表示学生的个数，接下来的一行，包含 n 个整数，按顺序表示每个学生的能力值 ai（-50 <= ai <= 50）。接下来的一行包含两个整数，k 和 d (1 <= k <= 10, 1 <= d <= 50)。
```
## 输出描述:

```
输出一行表示最大的乘积。
```
## 示例1 
### 输入

```
3
7 4 7
2 50
```
### 输出

```
49
```

## 思路：

```
这道题用了动态规划，我也是研究了好久，记录下整个思路，以免以后又忘了。。。

题目要求是：要选取n个人中的k个人，他们的能力乘积最大，而且这k个人的排序顺序不能超过d，能力值可以为负。
后面两个条件暂时先不用管，只要在前面基础上加一些限制条件就可以实现了。所以先分析问题：

首先，将这个问题切分成多个子问题，要n个人中选取k个人，先假设只有1个人，那就只能选1个人，记为f[1][1]，返回的乘积就是这个人的能力值nengli[1]。

现在总人数要升级到2个人了，如果在2个人中选一个人，那么要么是1号f[1][1](k是要选的人数，i是挑选的最后一个人的序号，因为是一个人所以就是被挑选的人)，要么2号f[1][2]，因为是一个人，根本不需要乘积，所以直接将各自的能力值代入，然后进行一个for循环比较，f[1][i]看谁大就可以了。

再升级一下， 在3个人中选择2个人。这就开始正式切分成子问题了。首先，通过刚才的计算已经知道了3个人中每个人的能力值了。
3个人选两个人，有以下这些选择：
- 1号，2号
- 1号，3号
- 2号，3号
我们只记录被挑选的最后一个人的序号，所以就是计算下面2个谁比较大。
- f[3][2]   # 对应了上面的第1个
- f[3][3]   # 对应了上面的第2，3个
对于f[3][2]，我们已经知道了f[2][1]的值了，所以用f[2][1]的值乘第二个人的能力值nengli[2]。
对于f[3][3]，有2个选择，那么就可以用f[2][1]的值乘第三个人的值，或者f[2][2]的值乘第三个人的值。然后进行比较。而f[2][1]、f[2][2]这两个值都已经知道了啊。

同理就可以计算更多人了。

因为能力值可能为负，所以也许刚刚还是最小的乘积（负的），然后乘一个负数，就突然变成最大的了。所以同时还要记录每次的最小乘积值，也就是把f这个数组，写成fmax，和fmin两个。

至于d，只需要在循环中就上这个限制条件就可以了。 
```

## 代码

```
#include<stdio.h>
#include<limits.h>
long long max(long long a,long long b){
	return a>b?a:b;
}
long long min(long long a,long long b){
	return a>b?b:a;
}
int main(){
	int num,K,d;
	int nengli[50];
	long long fmax[11][51],fmin[11][51];
	scanf("%d",&num);
	long long ans = LONG_MIN;
	for(int i=1;i<=num;i++){
		scanf("%d",&nengli[i]);
	}
	scanf("%d %d", &K,&d);
	for(int i=0;i<11;i++)
		for(int j=0;j<51;j++)
			fmax[i][j]=fmin[i][j]=0ll;
	for(int i=1; i<=num; i++){
		// fmax[1][i]选择一个学生时，i学生结尾得到的值。
		fmax[1][i]=fmin[1][i]=nengli[i];
		for(int k=2;k<=K; k++){
			for(int j=i-1; j>0&&(i-j)<=d; --j){
				fmax[k][i] = max(fmax[k][i], max(fmax[k-1][j]*nengli[i],fmin[k-1][j]*nengli[i]));
				fmin[k][i] = min(fmin[k][i], min(fmax[k-1][j]*nengli[i],fmin[k-1][j]*nengli[i]));
			}
		}
		ans = max(ans,fmax[K][i]);
		// printf("%lld\n", ans);
	}
	printf("%lld\n", ans);
}
```