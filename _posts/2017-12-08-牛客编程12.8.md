---
layout: post
title:  "牛客刷题"
categories: 牛客
tags:  牛客 Python 算法
author: zaipingy
---

* content
{:toc}

# 袋鼠过河：
## 题目描述

```
一只袋鼠要从河这边跳到河对岸，河很宽，但是河中间打了很多桩子，每隔一米就有一个，每个桩子上都有一个弹簧，袋鼠跳到弹簧上就可以跳的更远。每个弹簧力量不同，用一个数字代表它的力量，如果弹簧力量为5，就代表袋鼠下一跳最多能够跳5米，如果为0，就会陷进去无法继续跳跃。河流一共N米宽，袋鼠初始位置就在第一个弹簧上面，要跳到最后一个弹簧之后就算过河了，给定每个弹簧的力量，求袋鼠最少需要多少跳能够到达对岸。如果无法到达输出-1
```





## 输入描述:

```
输入分两行，第一行是数组长度N (1 ≤ N ≤ 10000)，第二行是每一项的值，用空格分隔。
```
## 输出描述:

```
输出最少的跳数，无法到达输出-1
```
## 示例1
### 输入


```
5
2 0 1 1 1
```
### 输出


```
4
```
## 代码
```
#! /usr/bin/python
#-*- coding: utf-8 -*-
import sys
 
__author__ = 'zaipingY'
 
def main():
    n = input()
    a = map(int, raw_input().split())
    left = right = 0
    step = 0
 
    while True:
        will_loc = right
        for i in range(left, will_loc+1):
            will_loc = max(will_loc, i+a[i])
        left = right + 1
        right = will_loc
        step += 1
        if will_loc >= n and left <= right:
            print step
            return
        if right < left:
            print -1
            return
 
        pass
if __name__ == "__main__":
    main()
```


# 彩色宝石项链
## 题目描述

```
有一条彩色宝石项链，是由很多种不同的宝石组成的，包括红宝石，蓝宝石，钻石，翡翠，珍珠等。有一天国王把项链赏赐给了一个学者，并跟他说，你可以带走这条项链，但是王后很喜欢红宝石，蓝宝石，紫水晶，翡翠和钻石这五种，我要你从项链中截取连续的一小段还给我，这一段中必须包含所有的这五种宝石，剩下的部分你可以带走。如果无法找到则一个也无法带走。请帮助学者找出如何切分项链才能够拿到最多的宝石。
```
## 输入描述:

```
我们用每种字符代表一种宝石，A表示红宝石，B表示蓝宝石，C代表紫水晶，D代表翡翠，E代表钻石，F代表玉石，G代表玻璃等等，我们用一个全部为大写字母的字符序列表示项链的宝石序列，注意项链是首尾相接的。每行代表一种情况。
```
## 输出描述:

```
输出学者能够拿到的最多的宝石数量。每行一个
```
## 示例1
### 输入


```
ABCYDYE
ATTMBQECPD
```
### 输出


```
1
3

```
## 代码
```
import sys

def main():
    for s in sys.stdin.readlines():
        l = len(s)
        min = l
        for i in range(l):
            x = []
            for j in 'ABCDE':
                x.append(s.find(j))
            x.sort()
            if min > x[-1]:
                min = x[-1]
            s = s[1:] + s[0]
        print(l - min - 1)
    
def test():
    for s in sys.stdin.readlines():
        l = len(s.strip())
        min = l
        strings = s.strip() * 2
        for i in strings:
            x = []
            for j in 'ABCDE':
                x.append(strings.find(j))
            x.sort()
            if x.count(-1):
                break
            if min > x[-1]-x[0]:
                min = x[-1]-x[0]
            strings = strings[1:]
        print(l-min-1)

if __name__ == '__main__':
    test()
```