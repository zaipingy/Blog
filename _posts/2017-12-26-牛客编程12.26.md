---
layout: post
title:  "牛客刷题"
categories: 牛客
tags:  牛客 算法 C
author: zaipingy
---

* content
{:toc}

最近在看C语言，所以在牛客上做的题就用C去做了。

挑一些比较有意思的题，记录一下。

# 最强大脑
## 题目描述

```
小B乘火车和朋友们一起在N市到M市之间旅行。她在路途中时睡时醒。当她醒来观看窗外的风景时，注意到每个火车站都有一种特别颜色的旗帜，但是她看到的旗帜仅仅是经过的一小部分。小B在乘车过程中有两次清醒的时间，她到达旅程终点时处于睡梦中。出站时，她和朋友们谈论着一路的见闻，朋友们觉得很有意思，他们把N到和M之间经过车站的旗帜颜色依次列出来，然后告诉你小B记得的旗帜颜色序列，让你判断小B究竟是从N和M之间哪些方向才能看到所说颜色的旗帜，还是根本就不可能看到？颜色用字母代表，相同的字母代表相同的颜色，不同的字母则表示不同的颜色。
```





## 输入描述:

```
输入中有多组测试数据，每组测试数据包含三行，第一行为一个由小写拉丁字母构成的非空字符串，长度不超过10^5，表示N到M之间车站的颜色。火车从M向N运行时，经过的车站相同，只是方向相反。第二行为小B在第一次睡醒时看到的颜色序列，第三行为小B在第二次睡醒时看到的颜色序列。两个序列都是小写的拉丁字母构成的字符串，长度不超过100个字母。每个序列的颜色顺序排列按小B看到的时间顺序排列。
```
## 输出描述:

```
对每组测试数据，在单独的行中输出小B的旅行方向。
  
forward - 由N到M方向； 

backward -由M到N方向  

both - 两种方向都有可能；  

invalid - 不可能看到这样的颜色序列；
```
## 示例1 
### 输入

```
atob 
a 
b 
aaacaaa 
aca 
aa
```
### 输出

```
forward 
both
```
## 代码：

```

#include<stdio.h>
#include<string.h>

bool check(char a[],char b[]);
void reverse(char a[]);
int main(){
	char input[100000];
	char a[1000],b[1000];
	scanf("%s",input);
	scanf("%s",a);
	scanf("%s",b);
	bool zheng = check(input, strcat(a,b));
	reverse(input);
	// printf("%s\n", input);
	bool ni = check(input, a);
	// printf("%s %s\n",input, a);
	if(zheng&&ni){
		printf("both\n");
	}else if(zheng){
		printf("forward\n");
	}else if(ni){
		printf("backward\n");
	}else{
		printf("invalid");
	}

}
bool check(char a[], char b[]){
	bool flag = false;
	int i=0,j=0;
	while(!flag){
		if(a[i] == b[j]){
			j++;
		}
		i++;
		if(strlen(b) == j){
			flag = true;
			break;
		}
		if(strlen(a)==i){
			break;
		}
	}
	return flag;
}
void reverse(char a[]){
	int len = strlen(a);
	for(int i = 0;i < len/2;i++){
		char temp = a[i];
		a[i] = a[len-i-1];
		a[len-i-1] = temp;
	}
}
```

# 游戏任务标记
## 题目描述

```
游戏里面有很多各式各样的任务，其中有一种任务玩家只能做一次，这类任务一共有1024个，任务ID范围[1,1024]。请用32个unsigned int类型来记录着1024个任务是否已经完成。初始状态都是未完成。 输入两个参数，都是任务ID，需要设置第一个ID的任务为已经完成；并检查第二个ID的任务是否已经完成。 输出一个参数，如果第二个ID的任务已经完成输出1，如果未完成输出0。如果第一或第二个ID不在[1,1024]范围，则输出-1。
```
## 输入描述:

```
输入包括一行,两个整数表示人物ID.
```
## 输出描述:

```
输出是否完成
```
## 示例1 
### 输入

```
1024 1024
```
### 输出

```
1
```
## 代码

```
#include<stdio.h>
int main(){
	unsigned int input1,input2;
	unsigned int a[32];
	scanf("%d %d", &input1,&input2);
	if(input1<1 || input1>1024 || input2<1 || input2>1024){
		printf("-1\n");
		return 0;}
	a[(input1-1)/32] |= (1<<(input1-1)%32);
	printf("%d\n",(a[(input2-1)/32] >> (input2-1)%32) & 1);
	return 0;
}

```

# 饥饿的小易
## 题目描述

```
小易总是感觉饥饿，所以作为章鱼的小易经常出去寻找贝壳吃。最开始小易在一个初始位置x_0。对于小易所处的当前位置x，他只能通过神秘的力量移动到 4 * x + 3或者8 * x + 7。因为使用神秘力量要耗费太多体力，所以它只能使用神秘力量最多100,000次。贝壳总生长在能被1,000,000,007整除的位置(比如：位置0，位置1,000,000,007，位置2,000,000,014等)。小易需要你帮忙计算最少需要使用多少次神秘力量就能吃到贝壳。
```
## 输入描述:

```
输入一个初始位置x_0,范围在1到1,000,000,006
```
## 输出描述:

```
输出小易最少需要使用神秘力量的次数，如果使用次数使用完还没找到贝壳，则输出-1
```
## 示例1 
### 输入

```
125000000
```
### 输出

```
1
```
## 代码

```
#include<stdio.h>
#include<math.h>

int search(int position);
int main(){
	int position;
	scanf("%d", &position);
	if ((position % 1000000007)==0){
		printf("0");
		return 0;
	}
	search(position);
}
int search(int position){
	int temp = position;
	for(int i=1; i<300000;i++){
		temp = temp * 2 + 1;
		if((temp % 1000000007)==0){
			for(int j=0; j<=(i/2);j++){
				if ((i-2*j)%3==0){
					printf("%d\n", (i+j)/3);
					return 0;
				}
			}
		}
		temp %= 1000000007;
	}
	printf("-1\n");
    return 0;
}
```

