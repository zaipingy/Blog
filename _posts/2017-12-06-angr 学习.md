---
layout: post
title:  "angr 学习"
categories: angr
tags:  angr
author: zaipingy
---

* content
{:toc}

## 加载文件
需要分析的二进制文件。
```
>>> import angr
>>> proj = angr.Project('/bin/true')
```





对该文件分析的一些信息：

```
>>> import monkeyhex # this will format numerical results in hexadecimal
>>> proj.arch
<Arch AMD64 (LE)>
>>> proj.entry
0x401670
>>> proj.filename
'/bin/true'
```
## arch
该文件的架构信息
    1. arch.bits
    2. arch.btyes
    3. arch.name
    4.arch.memory_endness
    
entry是二进制文件的入口地址。

filename 是该二进制文件的绝对路径+文件名。

## loader
有一个CLE模块是用来处理该二进制文件加载后的虚拟地址空间的。而loader就是CLE模块处理后的结果。


```
>>> proj.loader
<Loaded true, maps [0x400000:0x5004000]>

>>> proj.loader.shared_objects # may look a little different for you!
{'ld-linux-x86-64.so.2': <ELF Object ld-2.24.so, maps [0x2000000:0x2227167]>,
 'libc.so.6': <ELF Object libc-2.24.so, maps [0x1000000:0x13c699f]>}

>>> proj.loader.min_addr
0x400000
>>> proj.loader.max_addr
0x5004000

>>> proj.loader.main_object  # we've loaded several binaries into this project. Here's the main one!
<ELF Object true, maps [0x400000:0x60721f]>

>>> proj.loader.main_object.execstack  # sample query: does this binary have an executable stack?
False
>>> proj.loader.main_object.pic  # sample query: is this binary position-independent?
True
```
- shared_objects 加载二进制文件还需要的一些库？
- loader.min_addr 最小地址
- loader.max_addr 最大地址

## factory
### factory.block(addr)
传入一个地址，然后会返回一个块，根据这个块的一些方法，可以得到很多这个块的信息。

   - block.pp()       
                 pretty-print 会返回该快的汇编语言
   - block.instructions 
                 该地址有多少条指令               
   - block.instructions_addr
                 返回一个列表，这些指令分别在哪些地址上
   - block.capstone
   - block.vex

### states

```
>>> state = proj.factory.entry_state()
<SimState @ 0x401670>
```
SimState 就是模拟程序的状态，project是整个二进制文件加载进去之后的实例化对象，而SimState就是程序具体执行时的状态。他里面包含了很多状态：
    - 寄存器
    - 内存
    - 文件系统的数据

```
>>> state.regs.rip        # get the current instruction pointer
<BV64 0x401670>
>>> state.regs.rax
<BV64 0x1c>
>>> state.mem[proj.entry].int.resolved  # interpret the memory at the entry point as a C int
<BV32 0x8949ed31>
```
这些状态都并不是Python 中的int类型，而是向量。这些向量都有一个length的属性用来描述他的宽度。

Python的int类型和向量之间的**转换**：

```
>>> bv = state.solver.BVV(0x1234, 32)       # create a 32-bit-wide bitvector with value 0x1234
<BV32 0x1234>                               # BVV stands for bitvector value
>>> state.solver.eval(bv)                # convert to python int
0x1234
```
可以将向量存储在寄存器中，或者直接存储Int类型，它会自动进行转换成适当的大小。

```
>>> state.regs.rsi = state.solver.BVV(3, 64)
>>> state.regs.rsi
<BV64 0x3>

>>> state.mem[0x1000].long = 4
>>> state.mem[0x1000].long.resolved
<BV64 0x4>
```
mem 接口用了一些Python的magic函数。所以可能会有点难理解。
   - .resolved 是将内存中的数据转换为向量。
   - .concrete 是将内存中的数据转换为int类型。

states中还有很多寄存器，如：

```
>>> state.regs.rdi
<BV64 reg_48_11_64{UNINITIALIZED}>
```
64位的rdi寄存器。

这就是**符号变量**，他是符号执行的基础。


## Simulation Managers

states只是描述了指定地址的程序状态，而当需要下一个点时，就不行了，于是就需要一个全局的仿真管理器。

```
>>> simgr = proj.factory.simulation_manager(state)
<SimulationManager with 1 active>
>>> simgr.active
[<SimState @ 0x401670>]
```
这个全局的管理器有很多隐藏的状态，如active。

```
>>> simgr.step()
```
这个方法可以用来执行程序，这样就改变了当前的状态，SimState对象在执行过程中被认为是不变的。可以在多轮执行时使用同一个state。

```
>>> simgr.active
[<SimState @ 0x1020300>]
>>> simgr.active[0].regs.rip                 # new and exciting!
<BV64 0x1020300>
>>> state.regs.rip                           # still the same!
<BV64 0x401670>
```
## Analyses

```
>>> proj.analyses.            # Press TAB here in ipython to get an autocomplete-listing of everything:
 proj.analyses.BackwardSlice        proj.analyses.CongruencyCheck      proj.analyses.reload_analyses       
 proj.analyses.BinaryOptimizer      proj.analyses.DDG                  proj.analyses.StaticHooker          
 proj.analyses.BinDiff              proj.analyses.DFG                  proj.analyses.VariableRecovery      
 proj.analyses.BoyScout             proj.analyses.Disassembly          proj.analyses.VariableRecoveryFast  
 proj.analyses.CDG                  proj.analyses.GirlScout            proj.analyses.Veritesting           
 proj.analyses.CFG                  proj.analyses.Identifier           proj.analyses.VFG                   
 proj.analyses.CFGAccurate          proj.analyses.LoopFinder           proj.analyses.VSA_DDG               
 proj.analyses.CFGFast              proj.analyses.Reassembler
```


```
# Originally, when we loaded this binary it also loaded all its dependencies into the same virtual address  space
# This is undesirable for most analysis.
>>> proj = angr.Project('/bin/true', auto_load_libs=False)
>>> cfg = proj.analyses.CFGFast()
<CFGFast Analysis Result at 0x2d85130>

# cfg.graph is a networkx DiGraph full of CFGNode instances
# You should go look up the networkx APIs to learn how to use this!
>>> cfg.graph
<networkx.classes.digraph.DiGraph at 0x2da43a0>
>>> len(cfg.graph.nodes())
951

# To get the CFGNode for a given address, use cfg.get_any_node
>>> entry_node = cfg.get_any_node(proj.entry)
>>> len(list(cfg.graph.successors(entry_node)))
2
```



