---
layout: post
title:  "angr 仿真管理器"
categories: angr
tags:  angr
author: zaipingy
---

* content
{:toc}

仿真管理器就是程序符号执行状态的一个管理器，可以对这些状态进行过滤，执行，合并等等。
首先，构造仿真管理器：

```
import angr
>>> proj = angr.Project('examples/fauxware/fauxware', auto_load_libs=False)
>>> state = proj.factory.entry_state()
>>> simgr = proj.factory.simgr(state)
```





这是得到程序入口处的地址，然后构造仿真管理器，这样这个管理器的开始状态就在这个入口地址。他有几个常用的属性：

```
>>> simgr.active
[<SimState @ 0x400580>]

>>> simgr.step()
>>> simgr.active
[<SimState @ 0x400540>]
```
active 就是当前管理器所在的地址，也就是start()函数的地址，step()后程序向下执行到一个要跳转的地方，这个二进制文件中就是跳到main()函数的地址。

我们可以通过active()函数来快速的让程序执行到我们想要到的地方：

```
# Step until the first symbolic branch
>>> while len(simgr.active) == 1:
...    simgr.step()

>>> simgr
<SimulationManager with 2 active>
>>> simgr.active
[<SimState @ 0x400692>, <SimState @ 0x400699>]
```
让程序一直运行，直到程序有了两个分支的时候，也就是当程序出现判断的时候，停止。

或者使用run()函数，直接让程序一直向下执行：

```
# Step until everything terminates
>>> simgr.run()
>>> simgr
<SimulationManager with 3 deadended>
```
因为没有下断点，所以程序会一直执行，直到结束，退出。

可以用explore()函数来搜索一些你需要的函数，angr中的例子：

```
>>> proj = angr.Project('examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a')
>>> simgr = proj.factory.simgr()
>>> simgr.explore(find=lambda s: "Congrats" in s.posix.dumps(1))
<SimulationManager with 1 active, 1 found>
>>> s = simgr.found[0]
>>> print s.posix.dumps(1)
Enter password: Congrats!

>>> flag = s.posix.dumps(0)
>>> print(flag)
g00dJ0B!
```
find参数是构造的限制条件，还可以使用avoid参数，来过滤一些不想要执行的函数，来减少执行时间。